import numpy as np
from scipy.sparse import diags
import yt
from tqdm import tqdm
import os

# Configuración global
GAMMA = 1.354
MACH = 1.7
FIELDS = ["density", "velocity_x", "velocity_y", "Temp"]
ROI_PARAMS = {
    'threshold': 100.0,
    'window_size': 5,
    'preset': 75,
    'offset': 1125
}

def calculate_mean_fields_with_roi(snapshot_files, root_path, max_level=2):
    """Calcula campos medios aplicando ROI dinámico en cada snapshot"""
    first_ds = yt.load(os.path.join(root_path, snapshot_files[0]))
    
    # Configuración de grilla base
    ref = int(np.prod(first_ds.ref_factors[0:max_level]))
    low = first_ds.domain_left_edge
    dims = first_ds.domain_dimensions * ref
    nx = dims[0]
    
    # Inicializar acumuladores
    accum = {field: [] for field in FIELDS}  # Usamos listas por ROI variable
    roi_height = ROI_PARAMS['preset'] + ROI_PARAMS['offset']
    
    # Procesar cada snapshot
    for file in tqdm(snapshot_files, desc="Calculando promedios con ROI dinámico"):
        ds = yt.load(os.path.join(root_path, file))
        cube = ds.covering_grid(max_level, left_edge=low, dims=dims, 
                              fields=[("boxlib", f) for f in FIELDS])
        
        # Detección dinámica de ROI (igual que en Q_hat)
        temp = cube[("boxlib", "Temp")].d[:, :, 0]
        profile = temp[0, :]
        diff_avg = np.convolve(np.diff(profile), 
                            np.ones(2*ROI_PARAMS['window_size']+1)/(2*ROI_PARAMS['window_size']+1), 
                            mode='same')
        base_candidates = np.where(diff_avg > ROI_PARAMS['threshold'])[0]
        
        if len(base_candidates) == 0:
            base_index = dims[1] // 2
        else:
            base_index = base_candidates[0]
        
        lower_bound = max(0, base_index - ROI_PARAMS['preset'])
        upper_bound = min(dims[1], base_index + ROI_PARAMS['offset'])
        
        # Extraer ROI para cada campo
        for field in FIELDS:
            roi = cube[("boxlib", field)].d[:, lower_bound:upper_bound, 0]
            accum[field].append(roi)
    
    # Calcular promedios asegurando dimensiones consistentes
    mean_fields = {}
    for field in FIELDS:
        # Encontrar altura máxima de ROI en todos los snapshots
        max_ny = max(roi.shape[1] for roi in accum[field])
        
        # Aplicar padding y calcular promedio
        padded_rois = []
        for roi in accum[field]:
            if roi.shape[1] < max_ny:
                pad_width = ((0, 0), (0, max_ny - roi.shape[1]))
                roi = np.pad(roi, pad_width, mode='constant', constant_values=0)
            padded_rois.append(roi)
        
        mean_fields[field] = np.mean(padded_rois, axis=0)
    
    # Obtener volúmenes de celda (asumiendo malla uniforme)
    if 'dx' in dir(cube):
        dV = cube.dx * cube.dy * cube.dz
    else:
        dV = np.prod(ds.domain_width / ds.domain_dimensions)
    
    return mean_fields, dV, mean_fields["density"].shape

def build_compressible_W_with_roi(mean_fields, cell_volume, dims):
    """Construye W considerando ROI dinámico"""
    nx, ny = dims
    n_points = nx * ny
    
    # Calcular pesos
    rho_mean = mean_fields["density"]
    T_mean = mean_fields["Temp"]
    
    w_rho = (T_mean / (GAMMA * rho_mean * MACH**2)).flatten()
    w_vel = rho_mean.flatten()
    w_temp = (rho_mean / (GAMMA * (GAMMA-1) * T_mean * MACH**2)).flatten()
    
    # Construir diagonal
    diagonal = np.empty(4 * n_points)
    diagonal[0::4] = w_rho    # ρ
    diagonal[1::4] = w_vel    # vx
    diagonal[2::4] = w_vel    # vy
    diagonal[3::4] = w_temp   # T
    
    # Aplicar volumen de celda
    diagonal *= cell_volume
    
    return diags(diagonal, 0, format='csr')

if __name__ == "__main__":
    # 1. Cargar snapshots
    root = "../../Simulaciones/S0.1"
    files = sorted([f for f in os.listdir(root) if "pltAMR2NSW_" in f], 
                  key=lambda x: int(x.split("_")[-1]))
    
    # 2. Calcular promedios con ROI dinámico (usar subset para eficiencia)
    subset = files[::max(1, len(files)//100)]  # Muestrear ~100 snapshots
    mean_fields, dV, dims = calculate_mean_fields_with_roi(subset, root)
    
    # 3. Construir W
    W = build_compressible_W_with_roi(mean_fields, dV, dims)
    
    # 4. Guardar (opcional)
    from scipy.sparse import save_npz
    save_npz(f"W_compressible_gamma{GAMMA}_Mach{MACH}_ROI.npz", W)
    
    print(f"Matriz W construida con ROI dinámico. Dimensiones: {W.shape}")
